package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
)

// ServiceConfig holds configuration for service generation
type ServiceConfig struct {
	ServiceName      string
	ServiceNameLower string
	OrgName          string
	Port             string
	MetricsPort      string
	DBPort           string
	RedisDB          string
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run generate-service.go <service-name>")
		fmt.Println("Example: go run generate-service.go user-api")
		os.Exit(1)
	}

	serviceName := os.Args[1]
	
	// Get additional configuration
	config := ServiceConfig{
		ServiceName:      strings.Title(strings.ReplaceAll(serviceName, "-", "")),
		ServiceNameLower: serviceName,
		OrgName:          getInput("Organization name (e.g., your-github-username)", "your-org"),
		Port:             getInput("Service port", getNextAvailablePort()),
		MetricsPort:      getInput("Metrics port", "9090"),
		DBPort:           getInput("Database port", "5432"),
		RedisDB:          getInput("Redis DB number", "0"),
	}

	fmt.Printf("\nGenerating service: %s\n", config.ServiceName)
	fmt.Printf("Service name (lower): %s\n", config.ServiceNameLower)
	fmt.Printf("Organization: %s\n", config.OrgName)
	fmt.Printf("Port: %s\n", config.Port)

	// Create service directory
	serviceDir := filepath.Join(".", config.ServiceNameLower)
	err := os.MkdirAll(serviceDir, 0755)
	if err != nil {
		fmt.Printf("Error creating service directory: %v\n", err)
		os.Exit(1)
	}

	// Create cmd/api directory
	cmdDir := filepath.Join(serviceDir, "cmd", "api")
	err = os.MkdirAll(cmdDir, 0755)
	if err != nil {
		fmt.Printf("Error creating cmd/api directory: %v\n", err)
		os.Exit(1)
	}

	// Generate files from templates
	templateDir := filepath.Join("templates", "service-template")
	
	// Generate main.go
	generateFromTemplate(
		filepath.Join(templateDir, "main.go.tmpl"),
		filepath.Join(cmdDir, "main.go"),
		config,
	)

	// Generate .env
	generateFromTemplate(
		filepath.Join(templateDir, ".env.tmpl"),
		filepath.Join(serviceDir, ".env"),
		config,
	)

	// Generate go.mod
	generateFromTemplate(
		filepath.Join(templateDir, "go.mod.tmpl"),
		filepath.Join(serviceDir, "go.mod"),
		config,
	)

	// Create additional directories
	createDirectories(serviceDir, []string{
		"internal/domain/entity",
		"internal/domain/service",
		"internal/application",
		"internal/interfaces/api/handler",
		"internal/interfaces/api/route",
		"internal/infrastructure/repository",
		"pkg",
		"test",
		"docs",
	})

	// Generate README.md
	generateReadme(serviceDir, config)
	
	// Generate Dockerfile
	generateDockerfile(serviceDir, config)

	// Generate docker-compose.yml
	generateDockerCompose(serviceDir, config)

	fmt.Printf("\n‚úÖ Service '%s' generated successfully!\n", config.ServiceName)
	fmt.Printf("üìÅ Location: %s\n", serviceDir)
	fmt.Printf("\nüöÄ Next steps:\n")
	fmt.Printf("1. cd %s\n", config.ServiceNameLower)
	fmt.Printf("2. go mod tidy\n")
	fmt.Printf("3. docker-compose up -d postgres redis  # Start dependencies\n")
	fmt.Printf("4. go run cmd/api/main.go               # Start the service\n")
	fmt.Printf("5. curl http://localhost:%s/health      # Test the service\n", config.Port)
}

func getInput(prompt, defaultValue string) string {
	fmt.Printf("%s [%s]: ", prompt, defaultValue)
	
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Scan()
	input := strings.TrimSpace(scanner.Text())
	
	if input == "" {
		return defaultValue
	}
	return input
}

func getNextAvailablePort() string {
	// Common ports for club management system services
	usedPorts := map[string]bool{
		"8080": true, // Common default
		"8081": true, // user-api
		"8083": true, // auth-api  
		"8084": true, // championship-api
		"8087": true, // calendar-api
		"8090": true, // notification-api
		"8091": true, // payments-api
		"8085": true, // bff-api
	}

	for port := 8082; port <= 8099; port++ {
		portStr := strconv.Itoa(port)
		if !usedPorts[portStr] {
			return portStr
		}
	}
	
	return "8082" // fallback
}

func generateFromTemplate(templatePath, outputPath string, config ServiceConfig) {
	// Read template
	tmplContent, err := os.ReadFile(templatePath)
	if err != nil {
		fmt.Printf("Error reading template %s: %v\n", templatePath, err)
		os.Exit(1)
	}

	// Parse template
	tmpl, err := template.New("service").Parse(string(tmplContent))
	if err != nil {
		fmt.Printf("Error parsing template %s: %v\n", templatePath, err)
		os.Exit(1)
	}

	// Create output file
	outFile, err := os.Create(outputPath)
	if err != nil {
		fmt.Printf("Error creating output file %s: %v\n", outputPath, err)
		os.Exit(1)
	}
	defer outFile.Close()

	// Execute template
	err = tmpl.Execute(outFile, config)
	if err != nil {
		fmt.Printf("Error executing template %s: %v\n", templatePath, err)
		os.Exit(1)
	}

	fmt.Printf("‚úÖ Generated: %s\n", outputPath)
}

func createDirectories(baseDir string, dirs []string) {
	for _, dir := range dirs {
		fullPath := filepath.Join(baseDir, dir)
		err := os.MkdirAll(fullPath, 0755)
		if err != nil {
			fmt.Printf("Error creating directory %s: %v\n", fullPath, err)
			continue
		}
		fmt.Printf("üìÅ Created: %s\n", fullPath)
	}
}

func generateReadme(serviceDir string, config ServiceConfig) {
	readmeContent := "# " + config.Name + `

API service built with GopherKit.

## Quick Start

### Prerequisites
- Go 1.24+
- PostgreSQL  
- Redis (optional)

### Installation

1. Install dependencies:
` + "```bash\n   go mod tidy\n```" + `

2. Start dependencies:
` + "```bash\n   docker-compose up -d postgres redis\n```" + `

3. Configure environment:
` + "```bash\n   cp .env .env.local\n   # Edit .env.local with your configuration\n```" + `

4. Run the service:
` + "```bash\n   go run cmd/api/main.go"
   \`\`\`

## Endpoints

- \`GET /health\` - Basic health check
- \`GET /health/ready\` - Readiness check
- \`GET /health/live\` - Liveness check
- \`GET /metrics\` - Prometheus metrics
- \`GET /api/v1/example\` - Example endpoint

## Development

### Adding New Endpoints

1. Create handlers in \`internal/interfaces/api/handler/\`
2. Add routes in \`internal/interfaces/api/route/\`
3. Update \`setupRoutes\` function in \`cmd/api/main.go\`

### Adding Database Models

1. Create models in \`internal/domain/entity/\`
2. Add to \`%sModels\` slice in \`cmd/api/main.go\`
3. Restart service to auto-migrate

### Testing

\`\`\`bash
go test ./...
\`\`\`

## Configuration

Service is configured via environment variables. See \`.env\` for all options.

Key variables:
- \`PORT\`: Service port (default: %s)
- \`DATABASE_URL\`: PostgreSQL connection string
- \`JWT_SECRET\`: JWT signing secret
- \`CACHE_ENABLED\`: Enable Redis cache

## Built with GopherKit

This service uses [GopherKit](https://github.com/lukcba-developers/gopherkit) for:
- ‚ö° Rapid development with minimal boilerplate
- üîí Security middleware (rate limiting, CORS, etc.)
- üìä Built-in observability (metrics, health checks)
- üóÑÔ∏è Database and cache integration
- üìù Structured logging with context
`, config.ServiceName, config.ServiceName, config.Port)

	err := os.WriteFile(filepath.Join(serviceDir, "README.md"), []byte(readmeContent), 0644)
	if err != nil {
		fmt.Printf("Error generating README: %v\n", err)
		return
	}
	fmt.Printf("‚úÖ Generated: %s/README.md\n", serviceDir)
}

func generateDockerfile(serviceDir string, config ServiceConfig) {
	dockerfileContent := fmt.Sprintf(`# Build stage
FROM golang:1.24-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -o main cmd/api/main.go

# Final stage
FROM alpine:latest

RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/

COPY --from=builder /app/main .
COPY --from=builder /app/.env .

EXPOSE %s %s
CMD ["./main"]
`, config.Port, config.MetricsPort)

	err := os.WriteFile(filepath.Join(serviceDir, "Dockerfile"), []byte(dockerfileContent), 0644)
	if err != nil {
		fmt.Printf("Error generating Dockerfile: %v\n", err)
		return
	}
	fmt.Printf("‚úÖ Generated: %s/Dockerfile\n", serviceDir)
}

func generateDockerCompose(serviceDir string, config ServiceConfig) {
	dockerComposeContent := fmt.Sprintf(`version: '3.8'

services:
  %s:
    build: .
    ports:
      - "%s:%s"
      - "%s:%s"
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@postgres:%s/%s_db
      - REDIS_HOST=redis
      - ENVIRONMENT=development
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: %s_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "%s:%s"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
`,
		config.ServiceNameLower,
		config.Port, config.Port,
		config.MetricsPort, config.MetricsPort,
		config.DBPort, config.ServiceNameLower,
		config.ServiceNameLower,
		config.DBPort, config.DBPort)

	err := os.WriteFile(filepath.Join(serviceDir, "docker-compose.yml"), []byte(dockerComposeContent), 0644)
	if err != nil {
		fmt.Printf("Error generating docker-compose.yml: %v\n", err)
		return
	}
	fmt.Printf("‚úÖ Generated: %s/docker-compose.yml\n", serviceDir)
}